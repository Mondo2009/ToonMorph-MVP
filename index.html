<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>ToonKit ‚Äî Assets + Episode Generator (One File)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        :root {
            --bg: #0c1118;
            --card: #111826;
            --ink: #eaf2ff;
            --ink2: #aac3ff;
            --mid: #182235;
            --accent: #3d88ff
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font: 14px/1.4 system-ui, Segoe UI, Roboto;
            overflow-y: scroll
        }

        header {
            padding: 14px 18px;
            border-bottom: 1px solid #1b2a39;
            background: #0e151f;
            display: flex;
            gap: 10px;
            align-items: center
        }

        h1 {
            font-size: 16px;
            margin: 0;
            color: var(--ink2)
        }

        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px
        }

        .tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .tabbtn {
            background: #132034;
            border: 1px solid #1b2a39;
            color: var(--ink);
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer
        }

        .tabbtn.active {
            background: var(--accent);
            border-color: transparent
        }

        .grid {
            display: grid;
            gap: 12px
        }

        .card {
            background: var(--card);
            border: 1px solid #1b2a39;
            border-radius: 10px;
            padding: 12px
        }

        label {
            display: block;
            margin: 6px 0 2px;
            opacity: .9
        }

        input,
        select,
        textarea,
        button {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #203044;
            background: #0f1c2f;
            color: var(--ink)
        }

        textarea {
            min-height: 120px
        }

        button.primary {
            background: var(--accent);
            border: 0;
            cursor: pointer
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap
        }

        canvas {
            background: #0d1522;
            border-radius: 8px;
            display: block;
            width: 100%;
            height: auto
        }

        small {
            opacity: .8
        }

        .pill {
            display: inline-block;
            background: #1a2a44;
            padding: 4px 8px;
            border-radius: 999px;
            margin: 2px 4px 0 0
        }

        .list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px
        }

        .thumb {
            background: #0b121e;
            border: 1px solid #1b2a39;
            border-radius: 8px;
            padding: 6px;
            text-align: center
        }

        .thumb canvas {
            width: 140px;
            height: 140px;
            object-fit: contain
        }

        .two {
            grid-template-columns: 260px 1fr
        }

        .hide {
            display: none
        }
    </style>
</head>

<body>
    <header>
        <h1>ToonKit ‚Äî Cutout Animation Pipeline (Assets + Episodes)</h1>
        <span class="pill">Client-side only</span>
        <span class="pill">Works on Netlify</span>
    </header>

    <main>
        <div class="tabs">
            <button class="tabbtn active" data-tab="assets">Assets</button>
            <button class="tabbtn" data-tab="episode">Episode</button>
            <button class="tabbtn" data-tab="library">Library</button>
        </div>

        <!-- ASSETS -->
        <section id="assets" class="grid two" style="margin-top:12px">
            <div class="card">
                <h3>Create Character</h3>
                <label>Name</label><input id="c_name" placeholder="e.g., Finnigan">
                <label>Head Shape</label>
                <select id="c_head">
                    <option value="circle">Circle</option>
                    <option value="oval">Oval</option>
                    <option value="square">Square</option>
                </select>
                <label>Skin Color</label><input id="c_skin" type="color" value="#f7d7b6">
                <label>Shirt Color</label><input id="c_shirt" type="color" value="#3d88ff">
                <label>Mouth Style</label>
                <select id="c_mouth">
                    <option value="flat">Flat</option>
                    <option value="smile">Smile</option>
                    <option value="tooth">Tooth</option>
                </select>
                <label>Eyes</label>
                <select id="c_eyes">
                    <option value="dot">Dots</option>
                    <option value="bean">Beans</option>
                    <option value="wide">Wide</option>
                </select>
                <label>Face Size</label>
                <input id="c_faceSize" type="range" min="0.5" max="1.3" step="0.1" value="1">
                <small>Adjust the overall face scale</small>

                <button id="c_make" class="primary" style="margin-top:8px">Generate Character</button>
                <button id="c_save" style="margin-top:6px">Save to Library</button>
                <button id="c_png" style="margin-top:6px">Download PNG Sprite</button>
                <p><small>Generates a simple cutout-style character with mouth frames for lip-flap. Saved items appear
                        in the Library tab.</small></p>
            </div>
            <div class="card">
                <canvas id="charCanvas" width="512" height="512"></canvas>
                <p><small>Tip: Each character sheet packs 4 mouth states across the top row. The animator uses those
                        frames while speaking.</small></p>
            </div>

            <div class="card">
                <h3>Create Background</h3>
                <label>Preset</label>
                <select id="b_preset">
                    <option value="gradient">Gradient Sky</option>
                    <option value="hills">Hills</option>
                    <option value="interior">Interior</option>
                    <option value="night">Night Street</option>
                </select>
                <label>Image Background</label>
                <select id="b_image">
                    <option value="">None</option>
                    <option value="Images/1.png">Image 1</option>
                    <option value="Images/2.png">Image 2</option>
                    <option value="Images/3.png">Image 3</option>
                    <option value="Images/4.png">Image 4</option>
                    <option value="Images/5.png">Image 5</option>
                    <option value="Images/6.png">Image 6</option>
                    <option value="Images/7.png">Image 7</option>
                    <option value="Images/8.png">Image 8</option>
                    <option value="Images/9.png">Image 9</option>
                    <option value="Images/10.png">Image 10</option>
                    <option value="Images/11.png">Image 11</option>
                    <option value="Images/12.png">Image 12</option>
                    <option value="Images/13.png">Image 12</option>
                </select>

                <label>Primary Color</label><input id="b_c1" type="color" value="#6ec3ff">
                <label>Secondary Color</label><input id="b_c2" type="color" value="#193047">
                <button id="b_make" class="primary" style="margin-top:8px">Generate Background</button>
                <button id="b_save" style="margin-top:6px">Save to Library</button>
                <button id="b_png" style="margin-top:6px">Download PNG</button>
            </div>
            <div class="card">
                <canvas id="bgCanvas" width="1280" height="720"></canvas>
                <p><small>Backgrounds are 1280√ó720 PNGs. Use multiple for scene changes.</small></p>
            </div>

            <div class="card">
                <h3>Bundle & Export</h3>
                <button id="zipBtn" class="primary">Download ZIP of Library</button>
                <p><small>Includes all saved characters and backgrounds. Handy to pass to a freelancer or to keep a
                        backup.</small></p>
            </div>
        </section>

        <!-- EPISODE -->
        <section id="episode" class="grid two hide" style="margin-top:12px">
            <div class="card">
                <h3>Script</h3>
                <textarea id="scriptBox" placeholder="One line per dialogue. Use NAME: line
                    ALMA: Welcome to Dreamburg.
                    BRAX: You again?!
                    ALMA: Relax, I brought snacks.">
                </textarea>

                <h3 style="margin-top:16px">Casting</h3>
                <div class="row">
                    <div style="flex:1">
                        <label>Character A (speaker for first line)</label>
                        <select id="charA"></select>
                    </div>
                    <div style="flex:1">
                        <label>Character B</label>
                        <select id="charB"></select>
                    </div>
                </div>

                <h3 style="margin-top:16px">Scene</h3>
                <label>Background</label>
                <select id="bgSel"></select>

                <h3 style="margin-top:16px">Voices</h3>
                <div class="row">
                    <div style="flex:1">
                        <label>Voice A</label><select id="vA"></select>
                    </div>
                    <div style="flex:1">
                        <label>Voice B</label><select id="vB"></select>
                    </div>
                </div>
                <label>Line Duration (s)</label><input id="lineSec" type="number" min="1" value="3">
                <button id="genBtn" class="primary" style="margin-top:10px">üé¨ Generate Episode</button>
                <button id="dlBtn" style="margin-top:8px">‚¨áÔ∏è Download Video (.webm)</button>
                <p><small>Simple lip-flap + cutout motion. Everything runs in your browser. You can host this file on
                        Netlify as-is.</small></p>
            </div>

            <div class="card">
                <canvas id="stage" width="1280" height="720"></canvas>
                <div style="margin-top:8px"><small id="status">Idle.</small></div>
            </div>
        </section>

        <!-- LIBRARY -->
        <section id="library" class="grid hide" style="margin-top:12px">
            <div class="card">
                <h3>Saved Characters</h3>
                <div id="charList" class="list"></div>
            </div>
            <div class="card">
                <h3>Saved Backgrounds</h3>
                <div id="bgList" class="list"></div>
            </div>
        </section>
    </main>

    <!-- ZIP helper -->
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

    <script>
        /* =========================================================
           Simple in-browser store (localStorage)
        ========================================================= */
        const store = {
            get(key, fallback) { try { return JSON.parse(localStorage.getItem(key)) ?? fallback } catch (_) { return fallback } },
            set(key, val) { localStorage.setItem(key, JSON.stringify(val)) }
        };
        const lib = {
            chars: store.get('tk_chars', []),   // {name, pngDataURL}
            bgs: store.get('tk_bgs', [])    // {name, pngDataURL}
        };
        function saveLib() { store.set('tk_chars', lib.chars); store.set('tk_bgs', lib.bgs); refreshLibrary(); refreshSelectors(); }

        /* =========================================================
           Tabs
        ========================================================= */
        const tabs = document.querySelectorAll('.tabbtn');
        const sections = { assets: document.getElementById('assets'), episode: document.getElementById('episode'), library: document.getElementById('library') };
        tabs.forEach(b => b.onclick = () => {
            tabs.forEach(x => x.classList.remove('active'));
            b.classList.add('active');
            Object.values(sections).forEach(s => s.classList.add('hide'));
            sections[b.dataset.tab].classList.remove('hide');
        });

        /* =========================================================
   Character generator
========================================================= */
        const c = {
            cvs: document.getElementById('charCanvas'),
            ctx: document.getElementById('charCanvas').getContext('2d'),
            name: document.getElementById('c_name'),
            head: document.getElementById('c_head'),
            skin: document.getElementById('c_skin'),
            shirt: document.getElementById('c_shirt'),
            mouth: document.getElementById('c_mouth'),
            eyes: document.getElementById('c_eyes'),
            faceSize: document.getElementById('c_faceSize') // ‚úÖ new slider reference
        };

        function drawHead(ctx, x, y, w, h, shape, color) {
            ctx.fillStyle = color;
            ctx.beginPath();
            if (shape === 'circle') {
                ctx.arc(x + w / 2, y + h / 2, Math.min(w, h) / 2, 0, Math.PI * 2);
            } else if (shape === 'oval') {
                ctx.ellipse(x + w / 2, y + h / 2, w / 2, h / 2, 0, 0, Math.PI * 2);
            } else {
                ctx.roundRect(x, y, w, h, 10);
            }
            ctx.fill();
        }

        function drawEyes(ctx, x, y, type, scale = 1) {
            ctx.fillStyle = '#111';
            if (type === 'dot') {
                ctx.beginPath();
                ctx.arc(x - 18 * scale, y, 4 * scale, 0, 6.28);
                ctx.arc(x + 18 * scale, y, 4 * scale, 0, 6.28);
                ctx.fill();
            }
            if (type === 'bean') {
                ctx.fillRect(x - 24 * scale, y - 5 * scale, 12 * scale, 10 * scale);
                ctx.fillRect(x + 12 * scale, y - 5 * scale, 12 * scale, 10 * scale);
            }
            if (type === 'wide') {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(x - 18 * scale, y, 12 * scale, 9 * scale, 0, 0, 6.28);
                ctx.ellipse(x + 18 * scale, y, 12 * scale, 9 * scale, 0, 0, 6.28);
                ctx.fill();
                ctx.fillStyle = '#111';
                ctx.beginPath();
                ctx.arc(x - 18 * scale, y, 4 * scale, 0, 6.28);
                ctx.arc(x + 18 * scale, y, 4 * scale, 0, 6.28);
                ctx.fill();
            }
        }

        function drawMouth(ctx, x, y, style, frame, scale = 1) {
            ctx.fillStyle = '#111';
            ctx.lineWidth = 2 * scale;

            if (style === 'flat') {
                if (frame === 0) ctx.fillRect(x - 12 * scale, y, 24 * scale, 4 * scale);
                if (frame === 1) ctx.fillRect(x - 12 * scale, y, 24 * scale, 6 * scale);
                if (frame === 2) ctx.fillRect(x - 18 * scale, y, 36 * scale, 10 * scale);
                if (frame === 3) {
                    ctx.beginPath();
                    ctx.ellipse(x, y + 5 * scale, 10 * scale, 12 * scale, 0, 0, 6.28);
                    ctx.fill();
                }
            }

            if (style === 'smile') {
                ctx.beginPath();
                if (frame === 0) {
                    ctx.arc(x, y, 12 * scale, 0, Math.PI, false);
                    ctx.lineWidth = 3 * scale;
                    ctx.strokeStyle = '#111';
                    ctx.stroke();
                }
                if (frame === 1) {
                    ctx.arc(x, y, 13 * scale, 0, Math.PI, false);
                    ctx.lineWidth = 5 * scale;
                    ctx.stroke();
                }
                if (frame === 2) {
                    ctx.arc(x, y, 14 * scale, 0, Math.PI, false);
                    ctx.lineWidth = 7 * scale;
                    ctx.stroke();
                }
                if (frame === 3) {
                    ctx.beginPath();
                    ctx.ellipse(x, y + 5 * scale, 10 * scale, 12 * scale, 0, 0, 6.28);
                    ctx.fill();
                }
            }

            if (style === 'tooth') {
                if (frame === 0) ctx.fillRect(x - 10 * scale, y, 20 * scale, 6 * scale);
                if (frame === 1) {
                    ctx.fillStyle = '#c22';
                    ctx.fillRect(x - 12 * scale, y, 24 * scale, 8 * scale);
                    ctx.fillStyle = '#fff';
                    for (let i = -10; i <= 10; i += 5)
                        ctx.fillRect(x + i * scale, y, 2 * scale, 4 * scale);
                }
                if (frame === 2) {
                    ctx.fillStyle = '#c22';
                    ctx.fillRect(x - 16 * scale, y, 32 * scale, 12 * scale);
                    ctx.fillStyle = '#fff';
                    for (let i = -14; i <= 14; i += 5)
                        ctx.fillRect(x + i * scale, y, 2 * scale, 6 * scale);
                }
                if (frame === 3) {
                    ctx.fillStyle = '#c22';
                    ctx.beginPath();
                    ctx.ellipse(x, y + 6 * scale, 12 * scale, 14 * scale, 0, 0, 6.28);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(x - 10 * scale, y, 20 * scale, 5 * scale);
                }
            }
        }

        function drawCharacterSheet() {
            const ctx = c.ctx,
                W = c.cvs.width,
                H = c.cvs.height;
            ctx.clearRect(0, 0, W, H);

            const scale = parseFloat(c.faceSize.value || 1); // ‚úÖ use for full-body scale
            const centerX = W / 2;
            const baseCenterY = H * 0.68;

            // Adjust vertical position slightly when scaling up or down
            const centerY = baseCenterY + (1 - scale) * 100;

            // üßç‚Äç‚ôÇÔ∏è Body (Torso)
            ctx.fillStyle = c.shirt.value;
            const torsoW = 110 * scale;
            const torsoH = 110 * scale;
            ctx.fillRect(centerX - torsoW / 2, centerY - 10 * scale, torsoW, torsoH);

            // üü§ Head
            const headSize = 120 * scale;
            drawHead(
                ctx,
                centerX - headSize / 2,
                centerY - 160 * scale,
                headSize,
                headSize,
                c.head.value,
                c.skin.value
            );

            // Eyes + Mouth (scaled with body)
            drawEyes(ctx, centerX, centerY - 112 * scale, c.eyes.value, scale);
            drawMouth(ctx, centerX, centerY - 86 * scale, c.mouth.value, 0, scale);

            // Mouth row frames (top small preview)
            for (let f = 0; f < 4; f++) {
                const x = 64 + f * 96,
                    y = 70;
                const headW = 52 * scale,
                    headH = 52 * scale;
                drawHead(ctx, x - headW / 2, y - headH / 2, headW, headH, 'circle', c.skin.value);
                drawEyes(ctx, x, y - 6 * scale, 'dot', scale);
                drawMouth(ctx, x, y + 2 * scale, c.mouth.value, f, scale);
                ctx.strokeStyle = '#22324a';
                ctx.strokeRect(x - 40, y - 40, 80, 80);
            }
        }


        document.getElementById('c_make').onclick = drawCharacterSheet;

        // ‚úÖ Optional: live preview while moving slider
        c.faceSize.addEventListener('input', drawCharacterSheet);

        document.getElementById('c_save').onclick = () => {
            const name = (c.name.value || 'Character') + ' #' + Math.floor(Math.random() * 1000);
            lib.chars.push({ name, pngDataURL: c.cvs.toDataURL('image/png') });
            saveLib();
            alert('Saved ' + name + ' to library.');
        };

        document.getElementById('c_png').onclick = () => {
            const a = document.createElement('a');
            a.href = c.cvs.toDataURL('image/png');
            a.download = (c.name.value || 'character') + '_sheet.png';
            a.click();
        };

        /* =========================================================
           Background generator
        ========================================================= */
        const bg = {
            cvs: document.getElementById('bgCanvas'),
            ctx: document.getElementById('bgCanvas').getContext('2d'),
            preset: document.getElementById('b_preset'),
            c1: document.getElementById('b_c1'),
            c2: document.getElementById('b_c2'),
            image: document.getElementById('b_image') // üÜï added
        };
        function drawBG() {
            const { ctx } = bg, W = bg.cvs.width, H = bg.cvs.height;
            ctx.clearRect(0, 0, W, H);

            const selectedImage = bg.image.value;

            if (selectedImage) {
                // üñºÔ∏è If an image is selected, load and draw it
                const img = new Image();
                img.onload = () => ctx.drawImage(img, 0, 0, W, H);
                img.src = selectedImage;
                return; // stop here so manual generation isn‚Äôt triggered
            }

            // üé® Otherwise, fall back to procedural background generation
            if (bg.preset.value === 'gradient') {
                const g = ctx.createLinearGradient(0, 0, 0, H);
                g.addColorStop(0, bg.c1.value);
                g.addColorStop(1, bg.c2.value);
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, W, H);
            }
            else if (bg.preset.value === 'hills') {
                const g = ctx.createLinearGradient(0, 0, 0, H);
                g.addColorStop(0, bg.c1.value);
                g.addColorStop(1, bg.c2.value);
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, W, H);
                ctx.fillStyle = '#28425f';
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.ellipse(150 + i * 300, H - 60 - i * 20, 260, 100 + i * 20, 0, 0, 6.28);
                    ctx.fill();
                }
            }
            else if (bg.preset.value === 'interior') {
                ctx.fillStyle = bg.c2.value;
                ctx.fillRect(0, 0, W, H);
                ctx.fillStyle = bg.c1.value;
                ctx.fillRect(120, 60, W - 240, H - 120);
                ctx.strokeStyle = '#22324a';
                ctx.lineWidth = 6;
                ctx.strokeRect(120, 60, W - 240, H - 120);
            }
            else if (bg.preset.value === 'night') {
                const g = ctx.createLinearGradient(0, 0, 0, H);
                g.addColorStop(0, '#0a0e18');
                g.addColorStop(1, '#081020');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, W, H);
                ctx.fillStyle = '#23334f';
                for (let x = 80; x < W; x += 180) {
                    ctx.fillRect(x, H - 140, 120, 140);
                }
                ctx.fillStyle = '#d8b85c';
                for (let x = 92; x < W; x += 180) {
                    for (let y = H - 130; y < H - 20; y += 22) {
                        if (Math.random() < 0.3) ctx.fillRect(x, y, 8, 12);
                    }
                }
            }
        }

        document.getElementById('b_make').onclick = drawBG;
        document.getElementById('b_save').onclick = () => {
            const name = bg.preset.value + '_' + Math.floor(Math.random() * 1000);
            lib.bgs.push({ name, pngDataURL: bg.cvs.toDataURL('image/png') });
            saveLib(); alert('Saved background: ' + name);
        };
        document.getElementById('b_png').onclick = () => {
            const a = document.createElement('a'); a.href = bg.cvs.toDataURL('image/png'); a.download = 'background.png'; a.click();
        };

        /* =========================================================
           Library view + selectors
        ========================================================= */
        function refreshLibrary() {
            const cl = document.getElementById('charList'); cl.innerHTML = '';
            lib.chars.forEach((ch, i) => {
                const div = document.createElement('div'); div.className = 'thumb';
                const img = new Image(); img.onload = () => { const c = document.createElement('canvas'); c.width = 140; c.height = 140; const x = c.getContext('2d'); x.drawImage(img, 0, 0, 140, 140); div.prepend(c); }; img.src = ch.pngDataURL;
                const p = document.createElement('div'); p.textContent = ch.name;
                const rm = document.createElement('button'); rm.textContent = 'Remove'; rm.onclick = () => { lib.chars.splice(i, 1); saveLib(); };
                div.append(p, rm); cl.append(div);
            });

            const bl = document.getElementById('bgList'); bl.innerHTML = '';
            lib.bgs.forEach((bg, i) => {
                const div = document.createElement('div'); div.className = 'thumb';
                const img = new Image(); img.onload = () => { const c = document.createElement('canvas'); c.width = 140; c.height = 80; const x = c.getContext('2d'); x.drawImage(img, 0, 0, 140, 80); div.prepend(c); }; img.src = bg.pngDataURL;
                const p = document.createElement('div'); p.textContent = bg.name;
                const rm = document.createElement('button'); rm.textContent = 'Remove'; rm.onclick = () => { lib.bgs.splice(i, 1); saveLib(); };
                div.append(p, rm); bl.append(div);
            });
        }
        function refreshSelectors() {
            const a = document.getElementById('charA'), b = document.getElementById('charB'), bg = document.getElementById('bgSel');
            function fill(sel, arr) { sel.innerHTML = ''; arr.forEach((it, i) => { const o = document.createElement('option'); o.value = i; o.textContent = it.name; sel.append(o); }); }
            fill(a, lib.chars); fill(b, lib.chars); fill(bg, lib.bgs);
        }
        refreshLibrary(); refreshSelectors();

        /* =========================================================
           ZIP export
        ========================================================= */
        document.getElementById('zipBtn').onclick = async () => {
            const zip = new JSZip();
            const chars = zip.folder('characters'); const bgs = zip.folder('backgrounds');
            for (const ch of lib.chars) { chars.file((ch.name + '.png').replace(/\s+/g, '_'), ch.pngDataURL.split(',')[1], { base64: true }); }
            for (const bg of lib.bgs) { bgs.file((bg.name + '.png').replace(/\s+/g, '_'), bg.pngDataURL.split(',')[1], { base64: true }); }
            const blob = await zip.generateAsync({ type: 'blob' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'toonkit_library.zip'; a.click();
        };

        /* =========================================================
           Voices list
        ========================================================= */
        const vA = document.getElementById('vA'), vB = document.getElementById('vB');
        function loadVoices() {
            const voices = speechSynthesis.getVoices();
            [vA, vB].forEach(sel => {
                sel.innerHTML = ''; voices.forEach(v => { const o = document.createElement('option'); o.value = v.name; o.textContent = v.name; sel.append(o); });
            });
        }
        loadVoices();
        speechSynthesis.onvoiceschanged = loadVoices;

        /* =========================================================
           Episode generator (two speakers, alternating)
        ========================================================= */
        const stage = document.getElementById('stage'), sctx = stage.getContext('2d');
        const statusEl = document.getElementById('status');
        let recorder, chunks = [];
        function drawCutoutScene(bgImg, chAImg, chBImg, mouthFrame, active) { // active: 'A' or 'B'
            // bg
            sctx.drawImage(bgImg, 0, 0, stage.width, stage.height);
            // place characters (A left, B right)
            const scale = 0.7, w = 512 * scale, h = 512 * scale, y = stage.height - h + 20;
            // helper to draw a sheet with selected mouth frame
            function drawChar(img, x) {
                sctx.drawImage(img, 0, 128, 512, 384, x, y, w, h); // body (bottom area)
                // mouth frame tiles at row 0: each 80√ó80 box visualization we drew; approximate:
                const tileW = 128, tileH = 128, sx = 64 + mouthFrame * 96 - 40, sy = 30;
                // we‚Äôll just draw the head area again (for a simple flap illusion)
                sctx.drawImage(img, 0, 0, 512, 256, x, y - 30, w, h / 2);
            }
            drawChar(chAImg, 160);
            drawChar(chBImg, stage.width - 160 - w);

            // active glow
            sctx.strokeStyle = 'rgba(124,192,255,.6)'; sctx.lineWidth = 8;
            if (active === 'A') { sctx.strokeRect(160 - 8, y - 38, w + 16, h + 46); }
            else { sctx.strokeRect(stage.width - 160 - w - 8, y - 38, w + 16, h + 46); }
        }
        function loadImg(src) { return new Promise((res, rej) => { const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = src; }); }
        function toDataURLImage(dataURL) { return loadImg(dataURL); }

        async function generateEpisode() {
            const lines = document.getElementById('scriptBox').value.split('\n').map(s => s.trim()).filter(Boolean);
            if (lines.length === 0) return alert('Paste a script first.');
            if (lib.chars.length < 2) return alert('Create/save at least two characters.');
            if (lib.bgs.length < 1) return alert('Create/save at least one background.');

            const a = lib.chars[+document.getElementById('charA').value || 0];
            const b = lib.chars[+document.getElementById('charB').value || 1];
            const bg = lib.bgs[+document.getElementById('bgSel').value || 0];
            const lineSec = Math.max(1, +document.getElementById('lineSec').value || 3);

            statusEl.textContent = 'Loading assets...';
            const [bgImg, chAImg, chBImg] = await Promise.all([toDataURLImage(bg.pngDataURL), toDataURLImage(a.pngDataURL), toDataURLImage(b.pngDataURL)]);

            const stream = stage.captureStream(30);
            chunks = []; recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.start();

            statusEl.textContent = 'Rendering... (it also speaks lines while recording)';

            // alternate speakers by NAME: prefix if present, else A/B automatically
            let speaker = 'A';
            for (const raw of lines) {
                let line = raw, who = null;
                const m = raw.match(/^([^:]+):(.*)$/);
                if (m) { who = m[1].trim().toUpperCase(); line = m[2].trim(); }
                if (who) { speaker = (who === a.name.toUpperCase()) ? 'A' : 'B'; }

                // speak
                const utter = new SpeechSynthesisUtterance(line);
                const voiceName = (speaker === 'A' ? vA.value : vB.value);
                const voice = speechSynthesis.getVoices().find(v => v.name === voiceName);
                if (voice) utter.voice = voice;
                speechSynthesis.speak(utter);

                const frames = Math.max(1, Math.floor(lineSec * 30));
                for (let f = 0; f < frames; f++) {
                    const mouth = (Math.floor(f / 5) % 4); // 0..3 cycles
                    drawCutoutScene(bgImg, chAImg, chBImg, mouth, speaker);
                    await new Promise(r => setTimeout(r, 1000 / 30));
                }
            }

            recorder.stop();
            statusEl.textContent = 'Done. Click ‚ÄúDownload Video‚Äù.';
        }

        document.getElementById('genBtn').onclick = generateEpisode;
        document.getElementById('dlBtn').onclick = () => {
            if (!chunks.length) return alert('No video recorded yet.');
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'episode.webm'; a.click();
            URL.revokeObjectURL(url);
        };

        /* =========================================================
           Init a couple of starter assets so you can test instantly
        ========================================================= */
        (function seedOnce() {
            if (lib.chars.length || lib.bgs.length) return;
            // make two quick characters + one background
            c.name.value = 'ALMA'; drawCharacterSheet(); lib.chars.push({ name: 'ALMA', pngDataURL: c.cvs.toDataURL('image/png') });
            c.name.value = 'BRAX'; c.shirt.value = '#e06c75'; drawCharacterSheet(); lib.chars.push({ name: 'BRAX', pngDataURL: c.cvs.toDataURL('image/png') });
            drawBG(); lib.bgs.push({ name: 'PARK', pngDataURL: bg.cvs.toDataURL('image/png') });
            saveLib();
            // prefill script
            document.getElementById('scriptBox').value =
                `ALMA: Welcome to Dreamburg, population mostly weird.
                 BRAX: You again? Don‚Äôt touch anything.
                 ALMA: That‚Äôs fair. I only touch snacks.
                 BRAX: ‚Ä¶I respect that.`;
        })();
    </script>
</body>

</html>